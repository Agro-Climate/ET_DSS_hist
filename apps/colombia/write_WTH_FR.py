#Author: Eunjin Han
#Institute: IRI-Columbia University
#Date: 5/25/2019
#Purpose: write *.WTH files for 100 ensemble years
#########################
# (a) call WGEN-PAR function to generate input file for WGEN main function
# (b) run WGEN executable generated by Fortran compiler
# (c) call bias-correction funtion for post-processing
#########################
import numpy as np
import pandas as pd
import time
import calendar
import os   
from os import path
import datetime    #to convert date to doy or vice versa
import sys

def write_WTH_FR(df_tab, df_gen, WTD_fname, Wdir_path):  
    sce_name = df_tab.sce_name.values[0] 
    WSTA =df_tab.stn_name.values[0] 
    LAT, LONG, ELEV, TAV, AMP = find_station_info(WSTA) 
    trimester1 = df_tab.Trimester1.values[0]  #"JJA followed by SON"
    planting_date = df_tab.PltDate.values[0]
    plt_year = planting_date[:4] 
    if planting_date is not None:
        date_object = datetime.datetime.strptime(planting_date, '%Y-%m-%d').date()
        plt_doy = date_object.timetuple().tm_yday

    plt_date = int(plt_year + repr(plt_doy).zfill(3))  #integer  #e.g. 2015310   # September 15, 2015   ********
    hv_date = plt_date + 210 #tentative harvest date => long enough considering delayed growth  
    
    #The first date of SCF season => From this date, n realizations of synthetic weather data are written in *.WTH
    #    Before, this date, observed weather data is written in *.WTH
    #This is needed in case of hindcast from which obs weather is available throughout the crop growing season
    #frst_date = 2015335   #******* from which ensemble 100 realizations are attached to the observed
    frst_date = find_frst_date(plt_date, hv_date, trimester1)  #frst_date in format YYYYDOY[int]
    IC_date = plt_date - 1  #for weather generation for IC => IC starts 1 days before the first planting date
    #adjust IC_date if initial conditionn belong to the previous year
    if plt_date%1000 == 1 : #<= 30:
        IC_date = (plt_date//1000 -1)*1000 + 365
        if calendar.isleap(plt_date//1000 -1):  IC_date = (plt_date//1000 -1)*1000 + 366

    #adjust hv_date if harvest moves to a next year
    yr_end_date = 365
    if calendar.isleap(plt_date//1000): yr_end_date = 366
    if hv_date%1000 > yr_end_date:
        hv_date = hv_date - yr_end_date + 1000
#============here
    # === Read daily observations into a dataframe (note: Feb 29th was skipped in df_obs)
    WTD_df_orig, df_obs = read_WTD(WTD_fname)
    #=================================================================
    #Last observed date of the weather data  
    # Note => In case of hindcast, we assume that observed data is available until start of SCF months
    WTD_last_year = WTD_df_orig.YEAR.values[-1] 
    WTD_last_doy = WTD_df_orig.DOY[WTD_df_orig["YEAR"] == WTD_last_year].values[-1]
    WTD_last_date = int(repr(WTD_last_year) + repr(WTD_last_doy))  #e.g., 2017090
    year_array = df_gen.iyear.unique()
    # nrealiz = year_array.shape[0]

    #write 100 WTH files for each year
    print( '==Create_WTH: Start to write 100 *.WTH files - please wait...')
    # 1) when only one year is needed (case #5), exclude case #6 (when SCF1 for JFM)
    # if plt_date//1000 == hv_date//1000 and plt_date//1000 == IC_date//1000 and SCF1_loc[0][0] != 12:
    #(a) write WGEN generated weather realizations from the beginning of crop growth (i.e., IC)
    if frst_date <= IC_date: 
        write_WTH_ensemble(IC_date, df_gen, Wdir_path, LAT, LONG, ELEV, TAV, AMP, sce_name)
        # if WTD_last_date < frst_date: 
        #     write_WTH_ensemble(IC_date, df_gen, Wdir_path, WSTA, LAT, LONG, ELEV, TAV, AMP, sce_name)
        # else:
        #     write_WTH_obs_ensemble(IC_date, frst_date, WTD_df_orig, df_gen, Wdir_path,  LAT, LONG, ELEV, TAV, AMP, sce_name)

    #(b) write observed weather until frst_date and then WGEN generated weather realizations 
    elif frst_date > IC_date: 
        if WTD_last_date >= frst_date:  
            #write observed weather until frst_date and then WGEN generated weather realizations => Q: why do not use all obs data?
            #This is the typical case of hindcast simulation
            write_WTH_obs_ensemble(IC_date, frst_date, WTD_df_orig, df_gen, Wdir_path, LAT, LONG, ELEV, TAV, AMP, sce_name)
        elif WTD_last_date >= IC_date and WTD_last_date < frst_date: 
            #write observed weather until WTD_last_date and then Fill the missing values between WTD_last_date and  IC_date with WGEN-output from climatology
            write_WTH_obs_ensemble(IC_date, WTD_last_date+1, WTD_df_orig, df_gen, Wdir_path, LAT, LONG, ELEV, TAV, AMP, sce_name)
        elif WTD_last_date < IC_date: #fill missing days between IC_date and frst_date with WGEN-output from climatology
            # print( '==Warning (2): Last observed weather data is before IC of crop simulation (i.e., 1 days before plating)')
            write_WTH_ensemble(IC_date, df_gen, Wdir_path, LAT, LONG, ELEV, TAV, AMP, sce_name)
        else:
            print('No case selected in writing WTH: plt_date//1000 == hv_date//1000 and plt_date//1000 == IC_date//1000')
            os.system('pause')
    # #write obs reference weather data (e.g., SANJ1501.WTH)
    # if WTD_last_date >= hv_date:  #write only when obs data is available for full groiwng period
    #     write_WTH_obs(IC_date, hv_date%1000, 1, WTD_df_orig, Wdir_path, WSTA, LAT, LONG, ELEV, TAV, AMP)

    return
#====================================================================
#===================================================================
#====================================================================
#===================================================================
#IC_date => YYYYDOY format in integer
def write_WTH_ensemble(IC_date, df_gen, Wdir_path, LAT, LONG, ELEV, TAV, AMP, sce_name):
    REFHT = -99.0
    WNDHT = -99.0
    year_array = df_gen.iyear.unique()
    nrealiz = year_array.shape[0]
    plt_year = IC_date//1000
    # start_date = IC_date%1000-1   #start_date [DOY integer]=> start date to write (e.g., IC date)
    start_date = 0  #EJ (6/15/2020): strt to write from DOY=1 of the year

    #check if planting year match with the year written in df_gen
    if plt_year != df_gen.YEAR.values[0]:
        print( '**ERROR in def write_WTH_ensemble: planting year does not match with the year WGEN generated ')
        os.system('pause')

    #EJ(8/4/2021) make ONE WTH file which contains long gerated weather data
    fout_WTH = path.join(Wdir_path, sce_name + '_all.WTH') 
    # fout_WTH = Wdir_path.replace("/","\\") + '\\' + sce_name + repr(plt_year)[2:4]+'99'+'.WTH'
    f1_rz = open(fout_WTH,"w") #opens file
    f1_rz.write("*WEATHER DATA : "+sce_name + "\n")
    f1_rz.write(" \n")
    f1_rz.write("@ INSI      LAT     LONG  ELEV   TAV   AMP REFHT WNDHT \n")
    f1_rz.write('{0:s} {1:4s} {2:8.3f} {3:8.3f} {4:5.1f} {5:5.1f} {6:5.1f} {7:5.1f} {8:5.1f}'.format(' ', sce_name,   
                LAT, LONG, ELEV, TAV, AMP, REFHT, WNDHT))         
    f1_rz.write(" \n")  
    f1_rz.write("@DATE  SRAD  TMAX  TMIN  RAIN  DEWP  WIND   PAR  EVAP  RHUM  \n")
   
    if calendar.isleap(plt_year):  
        ndays = 366
    else:
        ndays = 365

    #Convert float to int before writing dataframe to WTH file
    df_gen.DOY=df_gen.DOY.astype(int)  #convert float to int
    df_gen.YEAR=df_gen.YEAR.astype(int)
    df_gen['DOY']=df_gen['DOY'].apply(lambda x: '{0:0>3}'.format(x))  ## Add leading zeros to the integer column in Python

    #Make a new column for consecutive years
    df_gen["YEAR2"]=df_gen.YEAR.values + df_gen.iyear.values -1  #check
    df_gen.YEAR2 = df_gen.YEAR2.astype(int)

    for ii in range(0,nrealiz):      
        #second, write ensemble weather realizations
        #This is much time-efficient
        #source: https://stackoverflow.com/questions/53820891/speed-of-writing-a-numpy-array-to-a-text-file
        iyear = df_gen["YEAR2"].values[ndays*(ii)]  #one of the future generated years
        df_temp = df_gen.iloc[start_date:ndays*(ii+1)].copy()
        df = pd.DataFrame({'YYDOY':df_temp.YEAR2[:].astype(str).str.slice(start=2)+df_temp.DOY[:],
                    'SRAD':df_temp.SRAD.values,
                    'TMAX':df_temp.TMAX.values,
                    'TMIN':df_temp.TMIN.values,
                    'RAIN':df_temp.RAIN.values})
        
        if calendar.isleap(iyear):  
            # if calendar.isleap(plt_year):
            #     df2array = df.values  #convert datafrme to numpy array
            #     fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            #     fmt = '\n'.join([fmt]*df2array.shape[0])
            #     data = fmt % tuple(df2array.ravel())   
            #     f_rz.write(data)
            #     f_rz.write(" \n")
            # else:
            #=========write header
            fout_WTH = path.join(Wdir_path, sce_name.upper() + repr(plt_year+ii)[2:4]+'01.WTH') 
            f_rz = open(fout_WTH,"w") #opens file
            f_rz.write("*WEATHER DATA : "+sce_name + "\n")
            f_rz.write(" \n")
            f_rz.write("@ INSI      LAT     LONG  ELEV   TAV   AMP REFHT WNDHT \n")
            f_rz.write('{0:s} {1:4s} {2:8.3f} {3:8.3f} {4:5.1f} {5:5.1f} {6:5.1f} {7:5.1f} {8:5.1f}'.format(' ', sce_name,   
                        LAT, LONG, ELEV, TAV, AMP, REFHT, WNDHT))         
            f_rz.write(" \n")  
            f_rz.write("@DATE  SRAD  TMAX  TMIN  RAIN  DEWP  WIND   PAR  EVAP  RHUM  \n")
            #=========write header
            df2array = df.values
            df2array = np.vstack([df2array, df2array[-1,:]])  #copy data from 365 and make a data for DOY=366 in case of a leap year
            df2array[-1,0]= df2array[-1,0][:2] + '366'   #replace 365 with 366
            fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            fmt = '\n'.join([fmt]*df2array.shape[0])
            data = fmt % tuple(df2array.ravel())   
            f_rz.write(data)  #check
            f_rz.write(" \n")
            f_rz.close
        else:
            # if calendar.isleap(plt_year):
            #     df2array = df.values[:-1,:] #check => remove DOY=366
            #     fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            #     fmt = '\n'.join([fmt]*df2array.shape[0])
            #     data = fmt % tuple(df2array.ravel())   
            #     f_rz.write(data)  #check
            #     f_rz.write(" \n")
            # else:
            #=========write header
            fout_WTH = path.join(Wdir_path, sce_name.upper() + repr(plt_year+ii)[2:4]+'01.WTH') 
            f_rz = open(fout_WTH,"w") #opens file
            f_rz.write("*WEATHER DATA : "+sce_name + "\n")
            f_rz.write(" \n")
            f_rz.write("@ INSI      LAT     LONG  ELEV   TAV   AMP REFHT WNDHT \n")
            f_rz.write('{0:s} {1:4s} {2:8.3f} {3:8.3f} {4:5.1f} {5:5.1f} {6:5.1f} {7:5.1f} {8:5.1f}'.format(' ', sce_name,   
                        LAT, LONG, ELEV, TAV, AMP, REFHT, WNDHT))         
            f_rz.write(" \n")  
            f_rz.write("@DATE  SRAD  TMAX  TMIN  RAIN  DEWP  WIND   PAR  EVAP  RHUM  \n")
            #=========write header
            df2array = df.values
            fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            fmt = '\n'.join([fmt]*df2array.shape[0])
            data = fmt % tuple(df2array.ravel())   
            f_rz.write(data)
            f_rz.write(" \n")
            f_rz.close

        start_date = start_date + ndays  #move to next realizations for writing another new year
    #==============================================
    #EJ(8/4/2021)write one WTH file for 100 consecutive years => this file is ued for computing seasonal total rainfall "Rain_trimester_gen"
    start_date = 0  #EJ (6/15/2020): strt to write from DOY=1 of the year
    for ii in range(0,nrealiz):      
        #second, write ensemble weather realizations
        #This is much time-efficient
        #source: https://stackoverflow.com/questions/53820891/speed-of-writing-a-numpy-array-to-a-text-file
        iyear = df_gen["YEAR2"].values[ndays*(ii)]  #one of the future generated years
        df_temp = df_gen.iloc[start_date:ndays*(ii+1)].copy()
        df = pd.DataFrame({'YYDOY':df_temp.YEAR2[:].astype(str).str.slice(start=2)+df_temp.DOY[:],
                    'SRAD':df_temp.SRAD.values,
                    'TMAX':df_temp.TMAX.values,
                    'TMIN':df_temp.TMIN.values,
                    'RAIN':df_temp.RAIN.values})
        
        if calendar.isleap(iyear):  
            # if calendar.isleap(plt_year):
            #     df2array = df.values  #convert datafrme to numpy array
            #     fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            #     fmt = '\n'.join([fmt]*df2array.shape[0])
            #     data = fmt % tuple(df2array.ravel())   
            #     f_rz.write(data)
            #     f_rz.write(" \n")
            # else:
            df2array = df.values
            df2array = np.vstack([df2array, df2array[-1,:]])  #copy data from 365 and make a data for DOY=366 in case of a leap year
            df2array[-1,0]= df2array[-1,0][:2] + '366'   #replace 365 with 366
            fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            fmt = '\n'.join([fmt]*df2array.shape[0])
            data = fmt % tuple(df2array.ravel())   
            f1_rz.write(data)  #check
            f1_rz.write(" \n")
        else:
            # if calendar.isleap(plt_year):
            #     df2array = df.values[:-1,:] #check => remove DOY=366
            #     fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            #     fmt = '\n'.join([fmt]*df2array.shape[0])
            #     data = fmt % tuple(df2array.ravel())   
            #     f_rz.write(data)  #check
            #     f_rz.write(" \n")
            # else:
            df2array = df.values
            fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            fmt = '\n'.join([fmt]*df2array.shape[0])
            data = fmt % tuple(df2array.ravel())   
            f1_rz.write(data)
            f1_rz.write(" \n")
        start_date = start_date + ndays  #move to next realizations for writing another new year
    #==============================================
    f1_rz.close  #end of writing 100 years repeatedly 
    return


#frst_date1 [YYYYDOY format]=> the first date of SCF window
def write_WTH_obs_ensemble(IC_date, frst_date1, WTD_df, df_gen, Wdir_path, LAT, LONG, ELEV, TAV, AMP, sce_name):
    REFHT = -99.0
    WNDHT = -99.0
    year_array = df_gen.iyear.unique()
    nrealiz = year_array.shape[0]
    plt_year = IC_date//1000
    start_date = frst_date1%1000-1   #start_date [DOY inteer]=> start date to write ensemble weather realizations

    #check if planting year match with the year written in df_gen
    if plt_year != df_gen.YEAR.values[0]:
        print( '**ERROR in def write_WTH_ensemble: planting year does not match with the year WGEN generated ')
        os.system('pause')

    fout_WTH = path.join(Wdir_path, sce_name + '_all.WTH') 
    f1_rz = open(fout_WTH,"w") #opens file
    f1_rz.write("*WEATHER DATA : "+sce_name + "\n")
    f1_rz.write(" \n")
    f1_rz.write("@ INSI      LAT     LONG  ELEV   TAV   AMP REFHT WNDHT \n")
    f1_rz.write('{0:s} {1:4s} {2:8.3f} {3:8.3f} {4:5.1f} {5:5.1f} {6:5.1f} {7:5.1f} {8:5.1f}'.format(' ', sce_name,   
                LAT, LONG, ELEV, TAV, AMP, REFHT, WNDHT))         
    f1_rz.write(" \n")  
    f1_rz.write("@DATE  SRAD  TMAX  TMIN  RAIN  DEWP  WIND   PAR  EVAP  RHUM  \n")
   
    if calendar.isleap(frst_date1//1000):  
        ndays = 366
    else:
        ndays = 365

    #Convert float to int before writing dataframe to WTH file
    df_gen.DOY=df_gen.DOY.astype(int)  #convert float to int
    df_gen.YEAR=df_gen.YEAR.astype(int)
    df_gen['DOY']=df_gen['DOY'].apply(lambda x: '{0:0>3}'.format(x))  ## Add leading zeros to the integer column in Python

    #Make a new column for consecutive years
    df_gen["YEAR2"]=df_gen.YEAR.values + df_gen.iyear.values -1  #check
    df_gen.YEAR2 = df_gen.YEAR2.astype(int)


    #Extract a subset of WTD for observed weather data
    WTD_df2 = WTD_df[(WTD_df["YEAR"] == IC_date//1000) & (WTD_df["DOY"] >= IC_date%1000) & (WTD_df["DOY"] < frst_date1%1000)].copy()
    #EJ (6/15/2020): strt to write from DOY=1 of the year
    # WTD_df2 = WTD_df[(WTD_df["YEAR"] == IC_date//1000) & (WTD_df["DOY"] >= 1) & (WTD_df["DOY"] < frst_date1%1000)].copy()
    ## Add leading zeros to the integer column in Python
    WTD_df2['DOY']=WTD_df2['DOY'].apply(lambda x: '{0:0>3}'.format(x))
    WTD_df3 = pd.DataFrame({'YYDOY':WTD_df2.YEAR[:].astype(str).str.slice(start=2)+WTD_df2.DOY[:],
                'SRAD':WTD_df2.SRAD.values,
                'TMAX':WTD_df2.TMAX.values,
                'TMIN':WTD_df2.TMIN.values,
                'RAIN':WTD_df2.RAIN.values})
    
    #write 100 separate WTH files for 100 consecutive years
    for ii in range(0,nrealiz):
        iyear = df_gen["YEAR2"].values[ndays*(ii)]  #one of the future generated years
        #1) from DOY=1 to IC_date, write generate weather from climatology
        df_temp = df_gen.iloc[ndays*ii:ndays*ii+IC_date%1000-1].copy()
        df1 = pd.DataFrame({'YYDOY':df_temp.YEAR2[:].astype(str).str.slice(start=2)+df_temp.DOY[:],
                    'SRAD':df_temp.SRAD.values,
                    'TMAX':df_temp.TMAX.values,
                    'TMIN':df_temp.TMIN.values,
                    'RAIN':df_temp.RAIN.values})
        #2) from IC_date to frst_date1, obs weather
        df_obs = WTD_df3.copy()
        if ii > 0: #update year for the hypothetical future years
            temp = df_obs.YYDOY.values  #string in 'YYDOY'
            if int(temp[0][:2]) < 50:  #maybe 1950 is the threshold year to distinghish 1900s vs 2000s
                temp2 = temp.astype('int') + (2000 + ii)*1000 
            else:
                temp2 = temp.astype('int') + (1900 + ii)*1000
            df_obs["YYDOY"] = [x.astype('str')[2:] for x in temp2]

        #3) from frst_date1,  write generated weather from SCF
        df_temp = df_gen.iloc[start_date:ndays*(ii+1)].copy()
        df2 = pd.DataFrame({'YYDOY':df_temp.YEAR2[:].astype(str).str.slice(start=2)+df_temp.DOY[:],
                    'SRAD':df_temp.SRAD.values,
                    'TMAX':df_temp.TMAX.values,
                    'TMIN':df_temp.TMIN.values,
                    'RAIN':df_temp.RAIN.values})
        #concatenate 3 df
        df = df1.append(df_obs, ignore_index=True)
        df = df.append(df2, ignore_index=True)
        print(df)

        if calendar.isleap(iyear):  
            # if calendar.isleap(plt_year):
            #     df2array = df.values  #convert datafrme to numpy array
            #     fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            #     fmt = '\n'.join([fmt]*df2array.shape[0])
            #     data = fmt % tuple(df2array.ravel())   
            #     f_rz.write(data)
            #     f_rz.write(" \n")
            # else:
            #=========write header
            fout_WTH = path.join(Wdir_path, sce_name.upper() + repr(plt_year+ii)[2:4]+'01.WTH') 
            f_rz = open(fout_WTH,"w") #opens file
            f_rz.write("*WEATHER DATA : "+sce_name + "\n")
            f_rz.write(" \n")
            f_rz.write("@ INSI      LAT     LONG  ELEV   TAV   AMP REFHT WNDHT \n")
            f_rz.write('{0:s} {1:4s} {2:8.3f} {3:8.3f} {4:5.1f} {5:5.1f} {6:5.1f} {7:5.1f} {8:5.1f}'.format(' ', sce_name,   
                        LAT, LONG, ELEV, TAV, AMP, REFHT, WNDHT))         
            f_rz.write(" \n")  
            f_rz.write("@DATE  SRAD  TMAX  TMIN  RAIN  DEWP  WIND   PAR  EVAP  RHUM  \n")
            #=========write header
            df2array = df.values
            df2array = np.vstack([df2array, df2array[-1,:]])  #copy data from 365 and make a data for DOY=366 in case of a leap year
            df2array[-1,0]= df2array[-1,0][:2] + '366'   #replace 365 with 366
            fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            fmt = '\n'.join([fmt]*df2array.shape[0])
            data = fmt % tuple(df2array.ravel())   
            f_rz.write(data)  #check
            f_rz.write(" \n")
            f_rz.close
        else:
            # if calendar.isleap(plt_year):
            #     df2array = df.values[:-1,:] #check => remove DOY=366
            #     fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            #     fmt = '\n'.join([fmt]*df2array.shape[0])
            #     data = fmt % tuple(df2array.ravel())   
            #     f_rz.write(data)  #check
            #     f_rz.write(" \n")
            # else:
            #=========write header
            fout_WTH = path.join(Wdir_path, sce_name.upper() + repr(plt_year+ii)[2:4]+'01.WTH') 
            f_rz = open(fout_WTH,"w") #opens file
            f_rz.write("*WEATHER DATA : "+sce_name + "\n")
            f_rz.write(" \n")
            f_rz.write("@ INSI      LAT     LONG  ELEV   TAV   AMP REFHT WNDHT \n")
            f_rz.write('{0:s} {1:4s} {2:8.3f} {3:8.3f} {4:5.1f} {5:5.1f} {6:5.1f} {7:5.1f} {8:5.1f}'.format(' ', sce_name,   
                        LAT, LONG, ELEV, TAV, AMP, REFHT, WNDHT))         
            f_rz.write(" \n")  
            f_rz.write("@DATE  SRAD  TMAX  TMIN  RAIN  DEWP  WIND   PAR  EVAP  RHUM  \n")
            #=========write header
            df2array = df.values
            fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            fmt = '\n'.join([fmt]*df2array.shape[0])
            data = fmt % tuple(df2array.ravel())   
            f_rz.write(data)
            f_rz.write(" \n")
            f_rz.close

        start_date = start_date + ndays  #move to next realizations for writing another new year
    #==============================================================================================
    #EJ(8/4/2021)write one WTH file for 100 consecutive years => this file is ued for computing seasonal total rainfall "Rain_trimester_gen"
    start_date = frst_date1%1000-1   #start_date [DOY inteer]=> start date to write ensemble weather realizations
    for ii in range(0,nrealiz):
        iyear = df_gen["YEAR2"].values[ndays*(ii)]  #one of the future generated years
        #1) from DOY=1 to IC_date, write generate weather from climatology
        df_temp = df_gen.iloc[ndays*ii:ndays*ii+IC_date%1000-1].copy()
        df1 = pd.DataFrame({'YYDOY':df_temp.YEAR2[:].astype(str).str.slice(start=2)+df_temp.DOY[:],
                    'SRAD':df_temp.SRAD.values,
                    'TMAX':df_temp.TMAX.values,
                    'TMIN':df_temp.TMIN.values,
                    'RAIN':df_temp.RAIN.values})
        #2) from IC_date to frst_date1, obs weather
        df_obs = WTD_df3.copy()
        if ii > 0: #update year for the hypothetical future years
            temp = df_obs.YYDOY.values  #string in 'YYDOY'
            if int(temp[0][:2]) < 50:  #maybe 1950 is the threshold year to distinghish 1900s vs 2000s
                temp2 = temp.astype('int') + (2000 + ii)*1000 
            else:
                temp2 = temp.astype('int') + (1900 + ii)*1000
            df_obs["YYDOY"] = [x.astype('str')[2:] for x in temp2]

        #3) from frst_date1,  write generated weather from SCF
        df_temp = df_gen.iloc[start_date:ndays*(ii+1)].copy()
        df2 = pd.DataFrame({'YYDOY':df_temp.YEAR2[:].astype(str).str.slice(start=2)+df_temp.DOY[:],
                    'SRAD':df_temp.SRAD.values,
                    'TMAX':df_temp.TMAX.values,
                    'TMIN':df_temp.TMIN.values,
                    'RAIN':df_temp.RAIN.values})
        #concatenate 3 df
        df = df1.append(df_obs, ignore_index=True)
        df = df.append(df2, ignore_index=True)
        print(df)

        if calendar.isleap(iyear):  
            # if calendar.isleap(plt_year):
            #     df2array = df.values  #convert datafrme to numpy array
            #     fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            #     fmt = '\n'.join([fmt]*df2array.shape[0])
            #     data = fmt % tuple(df2array.ravel())   
            #     f_rz.write(data)
            #     f_rz.write(" \n")
            # else:
            df2array = df.values
            df2array = np.vstack([df2array, df2array[-1,:]])  #copy data from 365 and make a data for DOY=366 in case of a leap year
            df2array[-1,0]= df2array[-1,0][:2] + '366'   #replace 365 with 366
            fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            fmt = '\n'.join([fmt]*df2array.shape[0])
            data = fmt % tuple(df2array.ravel())   
            f1_rz.write(data)  #check
            f1_rz.write(" \n")
        else:
            # if calendar.isleap(plt_year):
            #     df2array = df.values[:-1,:] #check => remove DOY=366
            #     fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            #     fmt = '\n'.join([fmt]*df2array.shape[0])
            #     data = fmt % tuple(df2array.ravel())   
            #     f_rz.write(data)  #check
            #     f_rz.write(" \n")
            # else:
            df2array = df.values
            fmt = '%5s %5.1f %5.1f %5.1f %5.1f'
            fmt = '\n'.join([fmt]*df2array.shape[0])
            data = fmt % tuple(df2array.ravel())   
            f1_rz.write(data)
            f1_rz.write(" \n")
        start_date = start_date + ndays  #move to next realizations for writing another new year
    f1_rz.close
    return

#===================================================================
def find_station_info(station_name):
  station_dic = {
    'CNAT': {'LAT': 4.183, 'LONG':-74.967, 'ELEV': 431, 'TAV': 27.7, 'AMP': 1.5},  #Espinal, Nataima (IDEAM)
    'CTUR': {'LAT': 8.917, 'LONG':-75.583, 'ELEV': 40, 'TAV': 28.1, 'AMP': 1.1},   #Cerete, Turipana (IDEAM)
    'CUCH': {'LAT': 6.533, 'LONG':-73.200, 'ELEV': 975, 'TAV': 25.0, 'AMP': 1.9},  #Cucharo El
    'CUNI': {'LAT': 3.833, 'LONG':-76.300, 'ELEV': 979, 'TAV': 24.8, 'AMP': 1.0},  #La Union, La Unión Administrative Center
    'EAMO': {'LAT': 6.467, 'LONG':-72.967, 'ELEV': 1667, 'TAV': 19.4, 'AMP': 1.1},  #Esc Agr Mogotes
    'ZAPA': {'LAT': 6.800, 'LONG':-73.283, 'ELEV': 1810, 'TAV': 18.9, 'AMP': 0.8},   #Zapatoca
    'NATA': {'LAT': 4.183, 'LONG':-74.950, 'ELEV': 431, 'TAV': 27.7, 'AMP': 1.6},  #Nataima
    }
  LAT = station_dic[station_name]['LAT']  #check!
  LONG = station_dic[station_name]['LONG']
  ELEV = station_dic[station_name]['ELEV']
  TAV = station_dic[station_name]['TAV']
  AMP = station_dic[station_name]['AMP']

  return LAT, LONG, ELEV, TAV, AMP 

#======================================================================
# the first date of SCF window
def find_frst_date(plt_date, hv_date, trimester):  
  # #===================================================
  # m_doys_list = [1,32,60,91,121,152,182,213,244,274,305,335]  #starting date of each month for regular years
  # m_doys_list2 = [1,32,61,92,122,153,183,214,245,275,306,336]  #starting date of each month for leap years
  # #======================================================================
  #define a dictionary to determine the starting date of each trimester
  frst_dic = {"JFM":1,"FMA":32, "MAM":60, "AMJ":91, "MJJ":121, "JJA":152, "JAS":182, "ASO":213, "SON":244, "OND":274, "NDJ":305, "DJF":335}
  frst_dic_leap = {"JFM":1,"FMA":32, "MAM":61, "AMJ":92, "MJJ":122, "JJA":153, "JAS":183, "ASO":214, "SON":245, "OND":275, "NDJ":306, "DJF":336}

# https://docs.google.com/spreadsheets/d/1XnBcHzbTDtDJpHl9U9SX0AfNgDjy4Vci/edit#gid=520906445
  if trimester == 'JFM':  #=> JFM is always in YR2 and thus use harvest date as reference => Case #6
    if calendar.isleap(hv_date//1000):
      temp_doy = frst_dic_leap.get(trimester)
      frst_date = repr(hv_date) + repr(temp_doy).zfill(3)  
    else:
      temp_doy = frst_dic.get(trimester)
      frst_date = repr(plt_date//1000) + repr(temp_doy).zfill(3)  
  else:
    if calendar.isleap(plt_date//1000):
      temp_doy = frst_dic_leap.get(trimester)
      frst_date = repr(plt_date//1000) + repr(temp_doy).zfill(3)  
    else:
      temp_doy = frst_dic.get(trimester)
      frst_date = repr(plt_date//1000) + repr(temp_doy).zfill(3)  

  return int(frst_date)

#====================================================================
#===================================================================
# === Read daily observations into a dataframe (note: Feb 29th was skipped in df_obs)
def read_WTD(fname):
    #1) Read daily observations into a matrix (note: Feb 29th was skipped)
    # WTD_fname = r'C:\Users\Eunjin\IRI\Hybrid_WGEN\CNRA.WTD'
    #1) read observed weather *.WTD (skip 1st row - heading)
    data1 = np.loadtxt(fname,skiprows=1)
    #convert numpy array to dataframe
    WTD_df = pd.DataFrame({'YEAR':data1[:,0].astype(int)//1000,    #python 3.6: / --> //
                    'DOY':data1[:,0].astype(int)%1000,
                    'SRAD':data1[:,1],
                    'TMAX':data1[:,2],
                    'TMIN':data1[:,3],
                    'RAIN':data1[:,4]})
    #make a copy of original WTD dataframe 
    WTD_df_orig = WTD_df.copy()
    #=== Extract only years with full 365/366 days:  by checking last obs year if it is incomplete or not
    WTD_last_year = WTD_df.YEAR.values[-1] 
    WTD_last_doy = WTD_df.DOY[WTD_df["YEAR"] == WTD_last_year].values[-1]
    if calendar.isleap(WTD_last_year):
        if WTD_last_doy < 366:
            indexNames = WTD_df[WTD_df["YEAR"] == WTD_last_year].index
            WTD_df.drop(indexNames , inplace=True) # Delete these row indexes from dataFrame
    else:
        if WTD_last_doy < 365:
            indexNames = WTD_df[WTD_df["YEAR"] == WTD_last_year].index
            WTD_df.drop(indexNames , inplace=True)    
    #=== Extract only years with full 365/366 days:  by checking first obs year if it is incomplete or not
    WTD_first_year = WTD_df.YEAR.values[0] 
    WTD_first_date = WTD_df.DOY[WTD_df["YEAR"] == WTD_first_year].values[0]
    if WTD_first_date > 1:
        if calendar.isleap(WTD_first_year):
            indexNames = WTD_df[WTD_df["YEAR"] == WTD_first_year].index
            WTD_df.drop(indexNames , inplace=True)
        else:
            indexNames = WTD_df[WTD_df["YEAR"] == WTD_first_year].index
            WTD_df.drop(indexNames , inplace=True) 
    #========================
    rain_WTD = WTD_df.RAIN.values
    srad_WTD = WTD_df.SRAD.values
    Tmax_WTD = WTD_df.TMAX.values
    Tmin_WTD = WTD_df.TMIN.values
    year_WTD = WTD_df.YEAR.values
    doy_WTD = WTD_df.DOY.values
    obs_yrs = np.unique(year_WTD).shape[0]
    #Exclude Feb. 29th in leapyears
    temp_indx = [1 if (calendar.isleap(year_WTD[i])) & (doy_WTD[i] == 29) else 0 for i in range(len(year_WTD))] #[f(x) if condition else g(x) for x in sequence]
    # Get the index of elements with value 15  result = np.where(arr == 15)
    rain_array = rain_WTD[np.where(np.asarray(temp_indx) == 0)]
    rain_array = np.reshape(rain_array, (obs_yrs,365))
    srad_array = srad_WTD[np.where(np.asarray(temp_indx) == 0)]
    srad_array = np.reshape(srad_array, (obs_yrs,365))
    Tmax_array = Tmax_WTD[np.where(np.asarray(temp_indx) == 0)]
    Tmax_array = np.reshape(Tmax_array, (obs_yrs,365))
    Tmin_array = Tmin_WTD[np.where(np.asarray(temp_indx) == 0)]
    Tmin_array = np.reshape(Tmin_array, (obs_yrs,365))

    #save dataframe into a csv file [Note: Feb 29th was excluded]
    df_obs = pd.DataFrame(np.zeros((obs_yrs*365, 6)))   
    df_obs.columns = ['YEAR','DOY','SRAD','TMAX','TMIN','RAIN']  #iyear => ith year
    df_obs.name = 'WTD_observed_365'
    k = 0
    for i in range(obs_yrs):
        iyear = np.unique(year_WTD)[i]
        df_obs.YEAR.iloc[k:365*(i+1)] = np.tile(iyear,(365,))
        df_obs.DOY.iloc[k:365*(i+1)]= np.asarray(range(1,366))
        df_obs.SRAD.iloc[k:365*(i+1)]= np.transpose(srad_array[i,:])
        df_obs.TMAX.iloc[k:365*(i+1)]= np.transpose(Tmax_array[i,:])
        df_obs.TMIN.iloc[k:365*(i+1)]= np.transpose(Tmin_array[i,:])
        df_obs.RAIN.iloc[k:365*(i+1)]= np.transpose(rain_array[i,:])
        k=k+365
    # #write dataframe into CSV file
    # df_obs.to_csv(Wdir_path +'//'+ df_obs.name + '.csv', index=False)
    del rain_WTD; del srad_WTD; del Tmax_WTD; del Tmin_WTD; del year_WTD; del doy_WTD
    del rain_array; del srad_array; del Tmax_array; del Tmin_array
    return WTD_df_orig, df_obs
#====================================================================
#===================================================================
